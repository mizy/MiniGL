<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: View/Canvas.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: View/Canvas.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
import Mesh from '../Mesh/Mesh';
import Point from '../Mesh/Point';
import Line from '../Mesh/Line';
import WidthLine from '../Mesh/WidthLine';
import { mat3 } from 'gl-matrix';
/**
 * @class
 */
class Canvas {
    constructor(config) {
        this.index = 0;
        this.meshes = [];
        this.miniGL = config.miniGL;
        this.gl = this.miniGL.gl;
        // 基础渲染以下类，其他形状让让用户自己new
        // 牺牲一些性能，渲染多次drawElements来避免通过退化三角形合并形状，导致的事件处理困难（需要分层处理合并的图层，然后按照像素去检测，比较恶心）
        this.mesh = new Mesh(config.meshConfig);
        this.point = new Point(config.pointConfig);
        this.line = new Line(config.lineConfig);
        this.widthLine = new WidthLine(config.widthLineConfig);
        this.add(this.mesh);
        this.add(this.line);
        this.add(this.point);
        this.add(this.widthLine);
    }

    dispose() {
        this.meshes.forEach(item => {
            this.remove(item);
            item.destroy &amp;&amp; item.destroy();
        });
        this.meshes = [];
    }

    toDataUrl() {
        return this.gl.canvas.toDataUrl();
    }

    status = 'update';

    update = () => {
        const time = new Date().getTime();
        const delta = time - this.beforeTime;
        this.beforeTime = time;
        this.render(delta);
        if (this.status === 'update')
            requestAnimationFrame(this.update);
    }
    /**
     * @param  {} mesh
     * @param  {} [key]
     * @returns {String} key
     */
    add(mesh) {
        this.meshes.push(mesh);
        mesh.onAdd &amp;&amp; mesh.onAdd(this.miniGL);
        mesh.parent = this;
        return mesh;
    }

    remove(child) {
        const index = this.meshes.indexOf(child);
        this.meshes.splice(index, 1);
    }

    addChild() {
        this.add.call(this, ...arguments);
    }

    removeChild() {
        this.remove.call(this, ...arguments);
    }

    render(delta) {
        const { gl } = this;
        this.miniGL.fire('beforerender', delta);
        // 清空
        gl.clearDepth(1.0);
        // gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.disable(gl.CULL_FACE);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.meshes.forEach(mesh => {
            this.renderMesh(mesh, delta);
        })
    }

    /**
     * @param  {} mesh
     * @param  {} delta
     * @param  {} parentMatrix 一级级传下来的矩阵
     */
    renderMesh(mesh, delta, parentMatrix) {
        const { gl } = this;

        const blendMode = (mesh.texture || {}).premultiplyAlpha ? 'ONE' : 'SRC_ALPHA';
        gl.enable(gl.BLEND);
        gl.blendFunc(gl[blendMode], mesh.blendMode || gl.ONE_MINUS_SRC_ALPHA);

        // 写入深度缓冲
        if (mesh.visible) {
            this.makeTransform(mesh, parentMatrix);
            this.makeNeedUniform(mesh);
            mesh.render(delta);
            // 更新子元素
            if (mesh.children) {
                mesh.children.forEach(item => {
                    this.renderMesh(item, delta, mesh.uniformData.modelView.value);
                });
            }
        }
    }

    makeNeedUniform(item) {
        item.uniformData.aspect = {
            value: this.miniGL.viewport.ratio,
            type: 'uniform1f'
        };
        item.uniformData.pixelRatio = {
            value: this.miniGL.viewport.pixelRatio,
            type: 'uniform1f'
        };
    }

    makeTransform(item, parentMatrix) {
        if (parentMatrix) {
            const modelView = mat3.mul(mat3.create(), parentMatrix, item.matrix);
            item.uniformData.modelView = {
                value: modelView,
                type: 'uniformMatrix3fv'
            };
        } else {
            item.uniformData.modelView = {
                value: item.matrix,
                type: 'uniformMatrix3fv'
            };
        }
        item.uniformData.transform = {
            value: this.miniGL.viewport.transform,
            type: 'uniformMatrix3fv'
        };
    }
}
export default Canvas;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a></li><li><a href="Canvas.html">Canvas</a></li><li><a href="Group.html">Group</a></li><li><a href="MiniGL.html">MiniGL</a></li><li><a href="MiniGLArmatureDisplay.html">MiniGLArmatureDisplay</a></li><li><a href="MiniGLSlot.html">MiniGLSlot</a></li><li><a href="MiniTextureData.html">MiniTextureData</a></li><li><a href="Rect.html">Rect</a></li><li><a href="ViewPort.html">ViewPort</a></li></ul><h3>Interfaces</h3><ul><li><a href="ShapeUtil.html">ShapeUtil</a></li></ul><h3>Global</h3><ul><li><a href="global.html#load">load</a></li><li><a href="global.html#loadImage">loadImage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sat Dec 11 2021 13:13:37 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
